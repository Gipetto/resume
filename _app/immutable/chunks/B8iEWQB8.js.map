{"version":3,"file":"B8iEWQB8.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/misc.js","../../../../../../node_modules/clsx/dist/clsx.mjs","../../../../../../node_modules/svelte/src/internal/shared/attributes.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/attributes.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/class.js","../../../../../../src/lib/services/i18n.svelte.ts","../../../../../../src/lib/components/Icon.svelte","../../../../../../src/lib/store.svelte.ts"],"sourcesContent":["import { hydrating } from '../hydration.js';\nimport { clear_text_content, get_first_child } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && get_first_child(dom) !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","function r(e){var t,f,n=\"\";if(\"string\"==typeof e||\"number\"==typeof e)n+=e;else if(\"object\"==typeof e)if(Array.isArray(e)){var o=e.length;for(t=0;t<o;t++)e[t]&&(f=r(e[t]))&&(n&&(n+=\" \"),n+=f)}else for(f in e)e[f]&&(n&&(n+=\" \"),n+=f);return n}export function clsx(){for(var e,t,f=0,n=\"\",o=arguments.length;f<o;f++)(e=arguments[f])&&(t=r(e))&&(n&&(n+=\" \"),n+=t);return n}export default clsx;","import { escape_html } from '../../escaping.js';\nimport { clsx as _clsx } from 'clsx';\n\n/**\n * `<div translate={false}>` should be rendered as `<div translate=\"no\">` and _not_\n * `<div translate=\"false\">`, which is equivalent to `<div translate=\"yes\">`. There\n * may be other odd cases that need to be added to this list in future\n * @type {Record<string, Map<any, string>>}\n */\nconst replacements = {\n\ttranslate: new Map([\n\t\t[true, 'yes'],\n\t\t[false, 'no']\n\t])\n};\n\n/**\n * @template V\n * @param {string} name\n * @param {V} value\n * @param {boolean} [is_boolean]\n * @returns {string}\n */\nexport function attr(name, value, is_boolean = false) {\n\tif (value == null || (!value && is_boolean) || (value === '' && name === 'class')) return '';\n\tconst normalized = (name in replacements && replacements[name].get(value)) || value;\n\tconst assignment = is_boolean ? '' : `=\"${escape_html(normalized, true)}\"`;\n\treturn ` ${name}${assignment}`;\n}\n\n/**\n * Small wrapper around clsx to preserve Svelte's (weird) handling of falsy values.\n * TODO Svelte 6 revisit this, and likely turn all falsy values into the empty string (what clsx also does)\n * @param  {any} value\n */\nexport function clsx(value) {\n\tif (typeof value === 'object') {\n\t\treturn _clsx(value);\n\t} else {\n\t\treturn value ?? '';\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { hydrating, set_hydrating } from '../hydration.js';\nimport { get_descriptors, get_prototype_of } from '../../../shared/utils.js';\nimport { create_event, delegate } from './events.js';\nimport { add_form_reset_listener, autofocus } from './misc.js';\nimport * as w from '../../warnings.js';\nimport { LOADING_ATTR_SYMBOL } from '../../constants.js';\nimport { queue_idle_task } from '../task.js';\nimport { is_capture_event, is_delegated, normalize_attribute } from '../../../../utils.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { clsx } from '../../../shared/attributes.js';\n\n/**\n * The value/checked attribute in the template actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLInputElement} input\n * @returns {void}\n */\nexport function remove_input_defaults(input) {\n\tif (!hydrating) return;\n\n\tvar already_removed = false;\n\n\t// We try and remove the default attributes later, rather than sync during hydration.\n\t// Doing it sync during hydration has a negative impact on performance, but deferring the\n\t// work in an idle task alleviates this greatly. If a form reset event comes in before\n\t// the idle callback, then we ensure the input defaults are cleared just before.\n\tvar remove_defaults = () => {\n\t\tif (already_removed) return;\n\t\talready_removed = true;\n\n\t\t// Remove the attributes but preserve the values\n\t\tif (input.hasAttribute('value')) {\n\t\t\tvar value = input.value;\n\t\t\tset_attribute(input, 'value', null);\n\t\t\tinput.value = value;\n\t\t}\n\n\t\tif (input.hasAttribute('checked')) {\n\t\t\tvar checked = input.checked;\n\t\t\tset_attribute(input, 'checked', null);\n\t\t\tinput.checked = checked;\n\t\t}\n\t};\n\n\t// @ts-expect-error\n\tinput.__on_r = remove_defaults;\n\tqueue_idle_task(remove_defaults);\n\tadd_form_reset_listener();\n}\n\n/**\n * @param {Element} element\n * @param {any} value\n */\nexport function set_value(element, value) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (\n\t\tattributes.value ===\n\t\t\t(attributes.value =\n\t\t\t\t// treat null and undefined the same for the initial value\n\t\t\t\tvalue ?? undefined) ||\n\t\t// @ts-expect-error\n\t\t// `progress` elements always need their value set when it's `0`\n\t\t(element.value === value && (value !== 0 || element.nodeName !== 'PROGRESS'))\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.value = value ?? '';\n}\n\n/**\n * @param {Element} element\n * @param {boolean} checked\n */\nexport function set_checked(element, checked) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (\n\t\tattributes.checked ===\n\t\t(attributes.checked =\n\t\t\t// treat null and undefined the same for the initial value\n\t\t\tchecked ?? undefined)\n\t) {\n\t\treturn;\n\t}\n\n\t// @ts-expect-error\n\telement.checked = checked;\n}\n\n/**\n * Sets the `selected` attribute on an `option` element.\n * Not set through the property because that doesn't reflect to the DOM,\n * which means it wouldn't be taken into account when a form is reset.\n * @param {HTMLOptionElement} element\n * @param {boolean} selected\n */\nexport function set_selected(element, selected) {\n\tif (selected) {\n\t\t// The selected option could've changed via user selection, and\n\t\t// setting the value without this check would set it back.\n\t\tif (!element.hasAttribute('selected')) {\n\t\t\telement.setAttribute('selected', '');\n\t\t}\n\t} else {\n\t\telement.removeAttribute('selected');\n\t}\n}\n\n/**\n * Applies the default checked property without influencing the current checked property.\n * @param {HTMLInputElement} element\n * @param {boolean} checked\n */\nexport function set_default_checked(element, checked) {\n\tconst existing_value = element.checked;\n\telement.defaultChecked = checked;\n\telement.checked = existing_value;\n}\n\n/**\n * Applies the default value property without influencing the current value property.\n * @param {HTMLInputElement | HTMLTextAreaElement} element\n * @param {string} value\n */\nexport function set_default_value(element, value) {\n\tconst existing_value = element.value;\n\telement.defaultValue = value;\n\telement.value = existing_value;\n}\n\n/**\n * @param {Element} element\n * @param {string} attribute\n * @param {string | null} value\n * @param {boolean} [skip_warning]\n */\nexport function set_attribute(element, attribute, value, skip_warning) {\n\t// @ts-expect-error\n\tvar attributes = (element.__attributes ??= {});\n\n\tif (hydrating) {\n\t\tattributes[attribute] = element.getAttribute(attribute);\n\n\t\tif (\n\t\t\tattribute === 'src' ||\n\t\t\tattribute === 'srcset' ||\n\t\t\t(attribute === 'href' && element.nodeName === 'LINK')\n\t\t) {\n\t\t\tif (!skip_warning) {\n\t\t\t\tcheck_src_in_dev_hydration(element, attribute, value ?? '');\n\t\t\t}\n\n\t\t\t// If we reset these attributes, they would result in another network request, which we want to avoid.\n\t\t\t// We assume they are the same between client and server as checking if they are equal is expensive\n\t\t\t// (we can't just compare the strings as they can be different between client and server but result in the\n\t\t\t// same url, so we would need to create hidden anchor elements to compare them)\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (attributes[attribute] === (attributes[attribute] = value)) return;\n\n\tif (attribute === 'style' && '__styles' in element) {\n\t\t// reset styles to force style: directive to update\n\t\telement.__styles = {};\n\t}\n\n\tif (attribute === 'loading') {\n\t\t// @ts-expect-error\n\t\telement[LOADING_ATTR_SYMBOL] = value;\n\t}\n\n\tif (value == null) {\n\t\telement.removeAttribute(attribute);\n\t} else if (typeof value !== 'string' && get_setters(element).includes(attribute)) {\n\t\t// @ts-ignore\n\t\telement[attribute] = value;\n\t} else {\n\t\telement.setAttribute(attribute, value);\n\t}\n}\n\n/**\n * @param {Element} dom\n * @param {string} attribute\n * @param {string} value\n */\nexport function set_xlink_attribute(dom, attribute, value) {\n\tdom.setAttributeNS('http://www.w3.org/1999/xlink', attribute, value);\n}\n\n/**\n * @param {HTMLElement} node\n * @param {string} prop\n * @param {any} value\n */\nexport function set_custom_element_data(node, prop, value) {\n\t// We need to ensure that setting custom element props, which can\n\t// invoke lifecycle methods on other custom elements, does not also\n\t// associate those lifecycle methods with the current active reaction\n\t// or effect\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet was_hydrating = hydrating;\n\tif (hydrating) {\n\t\tset_hydrating(false);\n\t}\n\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\tif (\n\t\t\t// Don't compute setters for custom elements while they aren't registered yet,\n\t\t\t// because during their upgrade/instantiation they might add more setters.\n\t\t\t// Instead, fall back to a simple \"an object, then set as property\" heuristic.\n\t\t\tsetters_cache.has(node.nodeName) ||\n\t\t\t// customElements may not be available in browser extension contexts\n\t\t\t!customElements ||\n\t\t\tcustomElements.get(node.tagName.toLowerCase())\n\t\t\t\t? get_setters(node).includes(prop)\n\t\t\t\t: value && typeof value === 'object'\n\t\t) {\n\t\t\t// @ts-expect-error\n\t\t\tnode[prop] = value;\n\t\t} else {\n\t\t\t// We did getters etc checks already, stringify before passing to set_attribute\n\t\t\t// to ensure it doesn't invoke the same logic again, and potentially populating\n\t\t\t// the setters cache too early.\n\t\t\tset_attribute(node, prop, value == null ? value : String(value));\n\t\t}\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t\tif (was_hydrating) {\n\t\t\tset_hydrating(true);\n\t\t}\n\t}\n}\n\n/**\n * Spreads attributes onto a DOM element, taking into account the currently set attributes\n * @param {Element & ElementCSSInlineStyle} element\n * @param {Record<string, any> | undefined} prev\n * @param {Record<string, any>} next New attributes - this function mutates this object\n * @param {string} [css_hash]\n * @param {boolean} [preserve_attribute_case]\n * @param {boolean} [is_custom_element]\n * @param {boolean} [skip_warning]\n * @returns {Record<string, any>}\n */\nexport function set_attributes(\n\telement,\n\tprev,\n\tnext,\n\tcss_hash,\n\tpreserve_attribute_case = false,\n\tis_custom_element = false,\n\tskip_warning = false\n) {\n\t// If we're hydrating but the custom element is from Svelte, and it already scaffolded,\n\t// then it might run block logic in hydration mode, which we have to prevent.\n\tlet is_hydrating_custom_element = hydrating && is_custom_element;\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(false);\n\t}\n\n\tvar current = prev || {};\n\tvar is_option_element = element.tagName === 'OPTION';\n\n\tfor (var key in prev) {\n\t\tif (!(key in next)) {\n\t\t\tnext[key] = null;\n\t\t}\n\t}\n\n\tif (next.class) {\n\t\tnext.class = clsx(next.class);\n\t}\n\n\tif (css_hash !== undefined) {\n\t\tnext.class = next.class ? next.class + ' ' + css_hash : css_hash;\n\t}\n\n\tvar setters = get_setters(element);\n\n\t// @ts-expect-error\n\tvar attributes = /** @type {Record<string, unknown>} **/ (element.__attributes ??= {});\n\n\t// since key is captured we use const\n\tfor (const key in next) {\n\t\t// let instead of var because referenced in a closure\n\t\tlet value = next[key];\n\n\t\t// Up here because we want to do this for the initial value, too, even if it's undefined,\n\t\t// and this wouldn't be reached in case of undefined because of the equality check below\n\t\tif (is_option_element && key === 'value' && value == null) {\n\t\t\t// The <option> element is a special case because removing the value attribute means\n\t\t\t// the value is set to the text content of the option element, and setting the value\n\t\t\t// to null or undefined means the value is set to the string \"null\" or \"undefined\".\n\t\t\t// To align with how we handle this case in non-spread-scenarios, this logic is needed.\n\t\t\t// There's a super-edge-case bug here that is left in in favor of smaller code size:\n\t\t\t// Because of the \"set missing props to null\" logic above, we can't differentiate\n\t\t\t// between a missing value and an explicitly set value of null or undefined. That means\n\t\t\t// that once set, the value attribute of an <option> element can't be removed. This is\n\t\t\t// a very rare edge case, and removing the attribute altogether isn't possible either\n\t\t\t// for the <option value={undefined}> case, so we're not losing any functionality here.\n\t\t\t// @ts-ignore\n\t\t\telement.value = element.__value = '';\n\t\t\tcurrent[key] = value;\n\t\t\tcontinue;\n\t\t}\n\n\t\tvar prev_value = current[key];\n\t\tif (value === prev_value) continue;\n\n\t\tcurrent[key] = value;\n\n\t\tvar prefix = key[0] + key[1]; // this is faster than key.slice(0, 2)\n\t\tif (prefix === '$$') continue;\n\n\t\tif (prefix === 'on') {\n\t\t\t/** @type {{ capture?: true }} */\n\t\t\tconst opts = {};\n\t\t\tconst event_handle_key = '$$' + key;\n\t\t\tlet event_name = key.slice(2);\n\t\t\tvar delegated = is_delegated(event_name);\n\n\t\t\tif (is_capture_event(event_name)) {\n\t\t\t\tevent_name = event_name.slice(0, -7);\n\t\t\t\topts.capture = true;\n\t\t\t}\n\n\t\t\tif (!delegated && prev_value) {\n\t\t\t\t// Listening to same event but different handler -> our handle function below takes care of this\n\t\t\t\t// If we were to remove and add listeners in this case, it could happen that the event is \"swallowed\"\n\t\t\t\t// (the browser seems to not know yet that a new one exists now) and doesn't reach the handler\n\t\t\t\t// https://github.com/sveltejs/svelte/issues/11903\n\t\t\t\tif (value != null) continue;\n\n\t\t\t\telement.removeEventListener(event_name, current[event_handle_key], opts);\n\t\t\t\tcurrent[event_handle_key] = null;\n\t\t\t}\n\n\t\t\tif (value != null) {\n\t\t\t\tif (!delegated) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @this {any}\n\t\t\t\t\t * @param {Event} evt\n\t\t\t\t\t */\n\t\t\t\t\tfunction handle(evt) {\n\t\t\t\t\t\tcurrent[key].call(this, evt);\n\t\t\t\t\t}\n\n\t\t\t\t\tcurrent[event_handle_key] = create_event(event_name, element, handle, opts);\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\telement[`__${event_name}`] = value;\n\t\t\t\t\tdelegate([event_name]);\n\t\t\t\t}\n\t\t\t} else if (delegated) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[`__${event_name}`] = undefined;\n\t\t\t}\n\t\t} else if (key === 'style' && value != null) {\n\t\t\telement.style.cssText = value + '';\n\t\t} else if (key === 'autofocus') {\n\t\t\tautofocus(/** @type {HTMLElement} */ (element), Boolean(value));\n\t\t} else if (!is_custom_element && (key === '__value' || (key === 'value' && value != null))) {\n\t\t\t// @ts-ignore We're not running this for custom elements because __value is actually\n\t\t\t// how Lit stores the current value on the element, and messing with that would break things.\n\t\t\telement.value = element.__value = value;\n\t\t} else if (key === 'selected' && is_option_element) {\n\t\t\tset_selected(/** @type {HTMLOptionElement} */ (element), value);\n\t\t} else {\n\t\t\tvar name = key;\n\t\t\tif (!preserve_attribute_case) {\n\t\t\t\tname = normalize_attribute(name);\n\t\t\t}\n\n\t\t\tvar is_default = name === 'defaultValue' || name === 'defaultChecked';\n\n\t\t\tif (value == null && !is_custom_element && !is_default) {\n\t\t\t\tattributes[key] = null;\n\n\t\t\t\tif (name === 'value' || name === 'checked') {\n\t\t\t\t\t// removing value/checked also removes defaultValue/defaultChecked — preserve\n\t\t\t\t\tlet input = /** @type {HTMLInputElement} */ (element);\n\t\t\t\t\tconst use_default = prev === undefined;\n\t\t\t\t\tif (name === 'value') {\n\t\t\t\t\t\tlet previous = input.defaultValue;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultValue = previous;\n\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\tinput.value = input.__value = use_default ? previous : null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tlet previous = input.defaultChecked;\n\t\t\t\t\t\tinput.removeAttribute(name);\n\t\t\t\t\t\tinput.defaultChecked = previous;\n\t\t\t\t\t\tinput.checked = use_default ? previous : false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\telement.removeAttribute(key);\n\t\t\t\t}\n\t\t\t} else if (\n\t\t\t\tis_default ||\n\t\t\t\t(setters.includes(name) && (is_custom_element || typeof value !== 'string'))\n\t\t\t) {\n\t\t\t\t// @ts-ignore\n\t\t\t\telement[name] = value;\n\t\t\t} else if (typeof value !== 'function') {\n\t\t\t\tset_attribute(element, name, value);\n\t\t\t}\n\t\t}\n\t\tif (key === 'style' && '__styles' in element) {\n\t\t\t// reset styles to force style: directive to update\n\t\t\telement.__styles = {};\n\t\t}\n\t}\n\n\tif (is_hydrating_custom_element) {\n\t\tset_hydrating(true);\n\t}\n\n\treturn current;\n}\n\n/** @type {Map<string, string[]>} */\nvar setters_cache = new Map();\n\n/** @param {Element} element */\nfunction get_setters(element) {\n\tvar setters = setters_cache.get(element.nodeName);\n\tif (setters) return setters;\n\tsetters_cache.set(element.nodeName, (setters = []));\n\n\tvar descriptors;\n\tvar proto = element; // In the case of custom elements there might be setters on the instance\n\tvar element_proto = Element.prototype;\n\n\t// Stop at Element, from there on there's only unnecessary setters we're not interested in\n\t// Do not use contructor.name here as that's unreliable in some browser environments\n\twhile (element_proto !== proto) {\n\t\tdescriptors = get_descriptors(proto);\n\n\t\tfor (var key in descriptors) {\n\t\t\tif (descriptors[key].set) {\n\t\t\t\tsetters.push(key);\n\t\t\t}\n\t\t}\n\n\t\tproto = get_prototype_of(proto);\n\t}\n\n\treturn setters;\n}\n\n/**\n * @param {any} element\n * @param {string} attribute\n * @param {string} value\n */\nfunction check_src_in_dev_hydration(element, attribute, value) {\n\tif (!DEV) return;\n\tif (attribute === 'srcset' && srcset_url_equal(element, value)) return;\n\tif (src_url_equal(element.getAttribute(attribute) ?? '', value)) return;\n\n\tw.hydration_attribute_changed(\n\t\tattribute,\n\t\telement.outerHTML.replace(element.innerHTML, element.innerHTML && '...'),\n\t\tString(value)\n\t);\n}\n\n/**\n * @param {string} element_src\n * @param {string} url\n * @returns {boolean}\n */\nfunction src_url_equal(element_src, url) {\n\tif (element_src === url) return true;\n\treturn new URL(element_src, document.baseURI).href === new URL(url, document.baseURI).href;\n}\n\n/** @param {string} srcset */\nfunction split_srcset(srcset) {\n\treturn srcset.split(',').map((src) => src.trim().split(' ').filter(Boolean));\n}\n\n/**\n * @param {HTMLSourceElement | HTMLImageElement} element\n * @param {string} srcset\n * @returns {boolean}\n */\nfunction srcset_url_equal(element, srcset) {\n\tvar element_urls = split_srcset(element.srcset);\n\tvar urls = split_srcset(srcset);\n\n\treturn (\n\t\turls.length === element_urls.length &&\n\t\turls.every(\n\t\t\t([url, width], i) =>\n\t\t\t\twidth === element_urls[i][1] &&\n\t\t\t\t// We need to test both ways because Vite will create an a full URL with\n\t\t\t\t// `new URL(asset, import.meta.url).href` for the client when `base: './'`, and the\n\t\t\t\t// relative URLs inside srcset are not automatically resolved to absolute URLs by\n\t\t\t\t// browsers (in contrast to img.src). This means both SSR and DOM code could\n\t\t\t\t// contain relative or absolute URLs.\n\t\t\t\t(src_url_equal(element_urls[i][0], url) || src_url_equal(url, element_urls[i][0]))\n\t\t)\n\t);\n}\n","import { hydrating } from '../hydration.js';\n\n/**\n * @param {SVGElement} dom\n * @param {string} value\n * @param {string} [hash]\n * @returns {void}\n */\nexport function set_svg_class(dom, value, hash) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value, hash);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {MathMLElement} dom\n * @param {string} value\n * @param {string} [hash]\n * @returns {void}\n */\nexport function set_mathml_class(dom, value, hash) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value, hash);\n\n\tif (hydrating && dom.getAttribute('class') === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.getAttribute('class') !== next_class_name)\n\t) {\n\t\tif (next_class_name === '') {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.setAttribute('class', next_class_name);\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @param {HTMLElement} dom\n * @param {string} value\n * @param {string} [hash]\n * @returns {void}\n */\nexport function set_class(dom, value, hash) {\n\t// @ts-expect-error need to add __className to patched prototype\n\tvar prev_class_name = dom.__className;\n\tvar next_class_name = to_class(value, hash);\n\n\tif (hydrating && dom.className === next_class_name) {\n\t\t// In case of hydration don't reset the class as it's already correct.\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t} else if (\n\t\tprev_class_name !== next_class_name ||\n\t\t(hydrating && dom.className !== next_class_name)\n\t) {\n\t\t// Removing the attribute when the value is only an empty string causes\n\t\t// peformance issues vs simply making the className an empty string. So\n\t\t// we should only remove the class if the the value is nullish.\n\t\tif (value == null && !hash) {\n\t\t\tdom.removeAttribute('class');\n\t\t} else {\n\t\t\tdom.className = next_class_name;\n\t\t}\n\n\t\t// @ts-expect-error need to add __className to patched prototype\n\t\tdom.__className = next_class_name;\n\t}\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {string} [hash]\n * @returns {string | V}\n */\nfunction to_class(value, hash) {\n\treturn (value == null ? '' : value) + (hash ? ' ' + hash : '');\n}\n\n/**\n * @param {Element} dom\n * @param {string} class_name\n * @param {boolean} value\n * @returns {void}\n */\nexport function toggle_class(dom, class_name, value) {\n\tif (value) {\n\t\tif (dom.classList.contains(class_name)) return;\n\t\tdom.classList.add(class_name);\n\t} else {\n\t\tif (!dom.classList.contains(class_name)) return;\n\t\tdom.classList.remove(class_name);\n\t}\n}\n","import stringsData from \"../data/strings-en_US.json\"\n\nconst uiStrings: {[key: string]: string} = stringsData\n\nconst _ = (key: string, _default: string = \"\"): string => {\n  // return uiStrings.hasOwnProperty(key) ? uiStrings[key] : _default\n  return Object.prototype.hasOwnProperty.call(uiStrings, key) ? uiStrings[key] : _default\n}\n\nexport default _\n","<script lang=\"ts\">\n  /* eslint-disable svelte/no-at-html-tags */\n  import * as icons from \"../icons.json\"\n  import type { IconData } from \"../types/icons\"\n\n  type IconName = keyof typeof icons\n  \n  const { \n    name,\n    width = 16,\n    height = 16,\n    title = undefined,\n    align = \"baseline\"\n  }: {\n    name: IconName\n    width?: number\n    height?: number\n    title?: string | undefined\n    align?: \"baseline\" | \"middle\"\n  } = $props()\n\n  const typedIcons: IconData = icons\n  const icon = typedIcons[name]\n</script>\n\n<svg\n  class=\"icon va-{align}\"\n  role=\"img\"\n  width={width}\n  height={height}\n  viewBox=\"0 0 {icon.viewBox.w} {icon.viewBox.h}\"\n  fill={icon.fill ?? \"none\"}\n  xmlns=\"http://www.w3.org/2000/svg\"\n  ><title>{@html title || icon.title}</title><g>{@html icon.svg}</g></svg\n>\n\n<style lang=\"scss\">\n  .icon {\n    position: relative;\n  }\n\n  :global {\n    .dark .icon {\n      fill: white;\n    }\n  }\n</style>","import { on } from \"svelte/events\"\nimport type { ResumeData, Theme } from \"../types/global\"\nimport { browser } from \"$app/environment\"\n\n// const jsonFetcher = async <T>(dataPath: string): Promise<T> => {\n//   return fetch(dataPath).then((res) => res.json())\n// }\n\n/**\n * Resume Data\n * @TODO - convert to Context\n */\n// const createResumeStore = () => {\n//   const content = $state<Loadable<ResumeData>>({\n//     isLoading: true,\n//     data: undefined\n//   })\n\n//   jsonFetcher<ResumeData>(\"data/content-en_US.json\").then((res) => {\n//     content.isLoading = false\n//     content.data = res\n//   })\n//     .catch((err) => {\n//       content.isLoading = false\n//       content.data = undefined\n//       content.error = \"There was an error loading the resume content. Check the console for more information.\"\n//       console.log(err)\n//     })\n\n//   return {\n//     get value() {\n//       return content\n//     },\n//     config: {\n//       useBullets() {\n//         return content.data?.config.history.bullets === true\n//       }\n//     },\n//     data<T extends keyof ResumeData>(field: T) {\n//       return content.data?.[field]\n//     }\n//   }\n// }\n\n// export const content = createResumeStore()\n\nimport resumeData from \"$lib/data/content-en_US.json\"\nclass ResumeStore {\n  data = $state<ResumeData>()\n\n  constructor(input: ResumeData) {\n    this.data = input\n  }\n\n  config<T extends keyof ResumeData[\"config\"]>(field: T) {\n    return this.data?.config[field]\n  }\n\n  get<T extends keyof ResumeData>(field: T) {\n    return this.data?.[field]\n  }\n}\n\nconst content = new ResumeStore(resumeData)\n\n/**\n * Color Theme\n */\nlet startingTheme: Theme = \"light\"\nlet browserThemePreference\n\nif (browser) {\n  const storedTheme = localStorage.getItem(\"theme\") as Theme\n  browserThemePreference = window.matchMedia(\"(prefers-color-scheme: dark)\")\n  startingTheme = storedTheme || (browserThemePreference.matches ? \"dark\" : \"light\")\n}\n\nconst createThemeStore = (initialValue: \"light\" | \"dark\") => {\n  let theme = $state(initialValue)\n\n  return {\n    get value() {\n      return theme\n    },\n    set value(value) {\n      theme = value\n      localStorage.setItem(\"theme\", theme)\n    }\n  }\n}\n\nconst theme = createThemeStore(startingTheme)\n\n// Handle the browser preferences changing\nif (browser && browserThemePreference) {\n  on(browserThemePreference, \"change\", (e) => {\n    /**\n     * The media query above is specifically for dark mode, \n     * so `e.matches` here is \"dark mode === true\"\n     */\n    theme.value = e.matches ? \"dark\" : \"light\"\n  })\n}\n\nexport {\n  content,\n  theme\n}"],"names":["autofocus","dom","value","body","queue_micro_task","r","f","n","o","clsx","_clsx","set_selected","element","selected","set_attribute","attribute","skip_warning","attributes","hydrating","LOADING_ATTR_SYMBOL","get_setters","set_attributes","prev","next","css_hash","preserve_attribute_case","is_custom_element","is_hydrating_custom_element","set_hydrating","current","is_option_element","key","setters","prev_value","prefix","opts","event_handle_key","event_name","delegated","is_delegated","is_capture_event","delegate","handle","evt","create_event","name","normalize_attribute","is_default","input","use_default","previous","setters_cache","descriptors","proto","element_proto","get_descriptors","get_prototype_of","set_svg_class","hash","prev_class_name","next_class_name","to_class","set_class","uiStrings","stringsData","_","_default","width","height","title","align","icon","icons","$$props","$.html","node_1","ResumeStore","field","_a","content","resumeData","startingTheme","browserThemePreference","storedTheme","createThemeStore","initialValue","theme","on"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4]}
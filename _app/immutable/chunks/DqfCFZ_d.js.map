{"version":3,"file":"DqfCFZ_d.js","sources":["../../../../../../node_modules/@sveltejs/kit/src/utils/routing.js"],"sourcesContent":["import { BROWSER } from 'esm-env';\n\nconst param_pattern = /^(\\[)?(\\.\\.\\.)?(\\w+)(?:=(\\w+))?(\\])?$/;\n\n/**\n * Creates the regex pattern, extracts parameter names, and generates types for a route\n * @param {string} id\n */\nexport function parse_route_id(id) {\n\t/** @type {import('types').RouteParam[]} */\n\tconst params = [];\n\n\tconst pattern =\n\t\tid === '/'\n\t\t\t? /^\\/$/\n\t\t\t: new RegExp(\n\t\t\t\t\t`^${get_route_segments(id)\n\t\t\t\t\t\t.map((segment) => {\n\t\t\t\t\t\t\t// special case — /[...rest]/ could contain zero segments\n\t\t\t\t\t\t\tconst rest_match = /^\\[\\.\\.\\.(\\w+)(?:=(\\w+))?\\]$/.exec(segment);\n\t\t\t\t\t\t\tif (rest_match) {\n\t\t\t\t\t\t\t\tparams.push({\n\t\t\t\t\t\t\t\t\tname: rest_match[1],\n\t\t\t\t\t\t\t\t\tmatcher: rest_match[2],\n\t\t\t\t\t\t\t\t\toptional: false,\n\t\t\t\t\t\t\t\t\trest: true,\n\t\t\t\t\t\t\t\t\tchained: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn '(?:/([^]*))?';\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// special case — /[[optional]]/ could contain zero segments\n\t\t\t\t\t\t\tconst optional_match = /^\\[\\[(\\w+)(?:=(\\w+))?\\]\\]$/.exec(segment);\n\t\t\t\t\t\t\tif (optional_match) {\n\t\t\t\t\t\t\t\tparams.push({\n\t\t\t\t\t\t\t\t\tname: optional_match[1],\n\t\t\t\t\t\t\t\t\tmatcher: optional_match[2],\n\t\t\t\t\t\t\t\t\toptional: true,\n\t\t\t\t\t\t\t\t\trest: false,\n\t\t\t\t\t\t\t\t\tchained: true\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\treturn '(?:/([^/]+))?';\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (!segment) {\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tconst parts = segment.split(/\\[(.+?)\\](?!\\])/);\n\t\t\t\t\t\t\tconst result = parts\n\t\t\t\t\t\t\t\t.map((content, i) => {\n\t\t\t\t\t\t\t\t\tif (i % 2) {\n\t\t\t\t\t\t\t\t\t\tif (content.startsWith('x+')) {\n\t\t\t\t\t\t\t\t\t\t\treturn escape(String.fromCharCode(parseInt(content.slice(2), 16)));\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tif (content.startsWith('u+')) {\n\t\t\t\t\t\t\t\t\t\t\treturn escape(\n\t\t\t\t\t\t\t\t\t\t\t\tString.fromCharCode(\n\t\t\t\t\t\t\t\t\t\t\t\t\t...content\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.slice(2)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.split('-')\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.map((code) => parseInt(code, 16))\n\t\t\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// We know the match cannot be null in the browser because manifest generation\n\t\t\t\t\t\t\t\t\t\t// would have invoked this during build and failed if we hit an invalid\n\t\t\t\t\t\t\t\t\t\t// param/matcher name with non-alphanumeric character.\n\t\t\t\t\t\t\t\t\t\tconst match = /** @type {RegExpExecArray} */ (param_pattern.exec(content));\n\t\t\t\t\t\t\t\t\t\tif (!BROWSER && !match) {\n\t\t\t\t\t\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t\t\t\t\t\t`Invalid param: ${content}. Params and matcher names can only have underscores and alphanumeric characters.`\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\tconst [, is_optional, is_rest, name, matcher] = match;\n\t\t\t\t\t\t\t\t\t\t// It's assumed that the following invalid route id cases are already checked\n\t\t\t\t\t\t\t\t\t\t// - unbalanced brackets\n\t\t\t\t\t\t\t\t\t\t// - optional param following rest param\n\n\t\t\t\t\t\t\t\t\t\tparams.push({\n\t\t\t\t\t\t\t\t\t\t\tname,\n\t\t\t\t\t\t\t\t\t\t\tmatcher,\n\t\t\t\t\t\t\t\t\t\t\toptional: !!is_optional,\n\t\t\t\t\t\t\t\t\t\t\trest: !!is_rest,\n\t\t\t\t\t\t\t\t\t\t\tchained: is_rest ? i === 1 && parts[0] === '' : false\n\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t\t\treturn is_rest ? '([^]*?)' : is_optional ? '([^/]*)?' : '([^/]+?)';\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturn escape(content);\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.join('');\n\n\t\t\t\t\t\t\treturn '/' + result;\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.join('')}/?$`\n\t\t\t\t);\n\n\treturn { pattern, params };\n}\n\nconst optional_param_regex = /\\/\\[\\[\\w+?(?:=\\w+)?\\]\\]/;\n\n/**\n * Removes optional params from a route ID.\n * @param {string} id\n * @returns The route id with optional params removed\n */\nexport function remove_optional_params(id) {\n\treturn id.replace(optional_param_regex, '');\n}\n\n/**\n * Returns `false` for `(group)` segments\n * @param {string} segment\n */\nfunction affects_path(segment) {\n\treturn segment !== '' && !/^\\([^)]+\\)$/.test(segment);\n}\n\n/**\n * Splits a route id into its segments, removing segments that\n * don't affect the path (i.e. groups). The root route is represented by `/`\n * and will be returned as `['']`.\n * @param {string} route\n * @returns string[]\n */\nexport function get_route_segments(route) {\n\treturn route.slice(1).split('/').filter(affects_path);\n}\n\n/**\n * @param {RegExpMatchArray} match\n * @param {import('types').RouteParam[]} params\n * @param {Record<string, import('@sveltejs/kit').ParamMatcher>} matchers\n */\nexport function exec(match, params, matchers) {\n\t/** @type {Record<string, string>} */\n\tconst result = {};\n\n\tconst values = match.slice(1);\n\tconst values_needing_match = values.filter((value) => value !== undefined);\n\n\tlet buffered = 0;\n\n\tfor (let i = 0; i < params.length; i += 1) {\n\t\tconst param = params[i];\n\t\tlet value = values[i - buffered];\n\n\t\t// in the `[[a=b]]/.../[...rest]` case, if one or more optional parameters\n\t\t// weren't matched, roll the skipped values into the rest\n\t\tif (param.chained && param.rest && buffered) {\n\t\t\tvalue = values\n\t\t\t\t.slice(i - buffered, i + 1)\n\t\t\t\t.filter((s) => s)\n\t\t\t\t.join('/');\n\n\t\t\tbuffered = 0;\n\t\t}\n\n\t\t// if `value` is undefined, it means this is an optional or rest parameter\n\t\tif (value === undefined) {\n\t\t\tif (param.rest) result[param.name] = '';\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!param.matcher || matchers[param.matcher](value)) {\n\t\t\tresult[param.name] = value;\n\n\t\t\t// Now that the params match, reset the buffer if the next param isn't the [...rest]\n\t\t\t// and the next value is defined, otherwise the buffer will cause us to skip values\n\t\t\tconst next_param = params[i + 1];\n\t\t\tconst next_value = values[i + 1];\n\t\t\tif (next_param && !next_param.rest && next_param.optional && next_value && param.chained) {\n\t\t\t\tbuffered = 0;\n\t\t\t}\n\n\t\t\t// There are no more params and no more values, but all non-empty values have been matched\n\t\t\tif (\n\t\t\t\t!next_param &&\n\t\t\t\t!next_value &&\n\t\t\t\tObject.keys(result).length === values_needing_match.length\n\t\t\t) {\n\t\t\t\tbuffered = 0;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\n\t\t// in the `/[[a=b]]/...` case, if the value didn't satisfy the matcher,\n\t\t// keep track of the number of skipped optional parameters and continue\n\t\tif (param.optional && param.chained) {\n\t\t\tbuffered++;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// otherwise, if the matcher returns `false`, the route did not match\n\t\treturn;\n\t}\n\n\tif (buffered) return;\n\treturn result;\n}\n\n/** @param {string} str */\nfunction escape(str) {\n\treturn (\n\t\tstr\n\t\t\t.normalize()\n\t\t\t// escape [ and ] before escaping other characters, since they are used in the replacements\n\t\t\t.replace(/[[\\]]/g, '\\\\$&')\n\t\t\t// replace %, /, ? and # with their encoded versions because decode_pathname leaves them untouched\n\t\t\t.replace(/%/g, '%25')\n\t\t\t.replace(/\\//g, '%2[Ff]')\n\t\t\t.replace(/\\?/g, '%3[Ff]')\n\t\t\t.replace(/#/g, '%23')\n\t\t\t// escape characters that have special meaning in regex\n\t\t\t.replace(/[.*+?^${}()|\\\\]/g, '\\\\$&')\n\t);\n}\n\nconst basic_param_pattern = /\\[(\\[)?(\\.\\.\\.)?(\\w+?)(?:=(\\w+))?\\]\\]?/g;\n\n/**\n * Populate a route ID with params to resolve a pathname.\n * @example\n * ```js\n * resolveRoute(\n *   `/blog/[slug]/[...somethingElse]`,\n *   {\n *     slug: 'hello-world',\n *     somethingElse: 'something/else'\n *   }\n * ); // `/blog/hello-world/something/else`\n * ```\n * @param {string} id\n * @param {Record<string, string | undefined>} params\n * @returns {string}\n */\nexport function resolve_route(id, params) {\n\tconst segments = get_route_segments(id);\n\tconst has_id_trailing_slash = id != '/' && id.endsWith('/');\n\n\treturn (\n\t\t'/' +\n\t\tsegments\n\t\t\t.map((segment) =>\n\t\t\t\tsegment.replace(basic_param_pattern, (_, optional, rest, name) => {\n\t\t\t\t\tconst param_value = params[name];\n\n\t\t\t\t\t// This is nested so TS correctly narrows the type\n\t\t\t\t\tif (!param_value) {\n\t\t\t\t\t\tif (optional) return '';\n\t\t\t\t\t\tif (rest && param_value !== undefined) return '';\n\t\t\t\t\t\tthrow new Error(`Missing parameter '${name}' in route ${id}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (param_value.startsWith('/') || param_value.endsWith('/'))\n\t\t\t\t\t\tthrow new Error(\n\t\t\t\t\t\t\t`Parameter '${name}' in route ${id} cannot start or end with a slash -- this would cause an invalid route like foo//bar`\n\t\t\t\t\t\t);\n\t\t\t\t\treturn param_value;\n\t\t\t\t})\n\t\t\t)\n\t\t\t.filter(Boolean)\n\t\t\t.join('/') +\n\t\t(has_id_trailing_slash ? '/' : '')\n\t);\n}\n\n/**\n * @param {import('types').SSRNode} node\n * @returns {boolean}\n */\nexport function has_server_load(node) {\n\treturn node.server?.load !== undefined || node.server?.trailingSlash !== undefined;\n}\n"],"names":["param_pattern","parse_route_id","id","params","get_route_segments","segment","rest_match","optional_match","parts","content","i","escape","code","match","is_optional","is_rest","name","matcher","affects_path","route","exec","matchers","result","values","values_needing_match","value","buffered","param","s","next_param","next_value","str","basic_param_pattern","resolve_route","segments","has_id_trailing_slash","_","optional","rest","param_value"],"mappings":"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","x_google_ignoreList":[0]}
{"version":3,"file":"CDXcGz5C.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js","../../../../../../node_modules/svelte/src/internal/client/dom/elements/events.js"],"sourcesContent":["import { teardown } from '../../../reactivity/effects.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../../runtime.js';\nimport { add_form_reset_listener } from '../misc.js';\n\n/**\n * Fires the handler once immediately (unless corresponding arg is set to `false`),\n * then listens to the given events until the render effect context is destroyed\n * @param {EventTarget} target\n * @param {Array<string>} events\n * @param {(event?: Event) => void} handler\n * @param {any} call_handler_immediately\n */\nexport function listen(target, events, handler, call_handler_immediately = true) {\n\tif (call_handler_immediately) {\n\t\thandler();\n\t}\n\n\tfor (var name of events) {\n\t\ttarget.addEventListener(name, handler);\n\t}\n\n\tteardown(() => {\n\t\tfor (var name of events) {\n\t\t\ttarget.removeEventListener(name, handler);\n\t\t}\n\t});\n}\n\n/**\n * @template T\n * @param {() => T} fn\n */\nexport function without_reactive_context(fn) {\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\ttry {\n\t\treturn fn();\n\t} finally {\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * Listen to the given event, and then instantiate a global form reset listener if not already done,\n * to notify all bindings when the form is reset\n * @param {HTMLElement} element\n * @param {string} event\n * @param {(is_reset?: true) => void} handler\n * @param {(is_reset?: true) => void} [on_reset]\n */\nexport function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {\n\telement.addEventListener(event, () => without_reactive_context(handler));\n\t// @ts-expect-error\n\tconst prev = element.__on_r;\n\tif (prev) {\n\t\t// special case for checkbox that can have multiple binds (group & checked)\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => {\n\t\t\tprev();\n\t\t\ton_reset(true);\n\t\t};\n\t} else {\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => on_reset(true);\n\t}\n\n\tadd_form_reset_listener();\n}\n","/** @import { Location } from 'locate-character' */\nimport { teardown } from '../../reactivity/effects.js';\nimport { define_property, is_array } from '../../../shared/utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\nimport { FILENAME } from '../../../../constants.js';\nimport * as w from '../../warnings.js';\nimport {\n\tactive_effect,\n\tactive_reaction,\n\tset_active_effect,\n\tset_active_reaction\n} from '../../runtime.js';\nimport { without_reactive_context } from './bindings/shared.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} [handler]\n * @param {AddEventListenerOptions} [options]\n */\nexport function create_event(event_name, dom, handler, options = {}) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation.call(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn without_reactive_context(() => {\n\t\t\t\treturn handler?.call(this, event);\n\t\t\t});\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events and touch events.\n\tif (\n\t\tevent_name.startsWith('pointer') ||\n\t\tevent_name.startsWith('touch') ||\n\t\tevent_name === 'wheel'\n\t) {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} [handler]\n * @param {boolean} [capture]\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @this {EventTarget}\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(event) {\n\tvar handler_element = this;\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\t// This started because of Chromium issue https://chromestatus.com/feature/5128696823545856,\n\t// where removal or moving of of the DOM can cause sync `blur` events to fire, which can cause logic\n\t// to run inside the current `active_reaction`, which isn't what we want at all. However, on reflection,\n\t// it's probably best that all event handled by Svelte have this behaviour, as we don't really want\n\t// an event handler to run in the context of another reaction or effect.\n\tvar previous_reaction = active_reaction;\n\tvar previous_effect = active_effect;\n\tset_active_reaction(null);\n\tset_active_effect(null);\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.assignedSlot ||\n\t\t\t\tcurrent_target.parentNode ||\n\t\t\t\t/** @type {any} */ (current_target).host ||\n\t\t\t\tnull;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-ignore remove proxy on currentTarget\n\t\tdelete event.currentTarget;\n\t\tset_active_reaction(previous_reaction);\n\t\tset_active_effect(previous_effect);\n\t}\n}\n\n/**\n * In dev, warn if an event handler is not a function, as it means the\n * user probably called the handler or forgot to add a `() =>`\n * @param {() => (event: Event, ...args: any) => void} thunk\n * @param {EventTarget} element\n * @param {[Event, ...any]} args\n * @param {any} component\n * @param {[number, number]} [loc]\n * @param {boolean} [remove_parens]\n */\nexport function apply(\n\tthunk,\n\telement,\n\targs,\n\tcomponent,\n\tloc,\n\thas_side_effects = false,\n\tremove_parens = false\n) {\n\tlet handler;\n\tlet error;\n\n\ttry {\n\t\thandler = thunk();\n\t} catch (e) {\n\t\terror = e;\n\t}\n\n\tif (typeof handler === 'function') {\n\t\thandler.apply(element, args);\n\t} else if (has_side_effects || handler != null || error) {\n\t\tconst filename = component?.[FILENAME];\n\t\tconst location = loc ? ` at ${filename}:${loc[0]}:${loc[1]}` : ` in ${filename}`;\n\n\t\tconst event_name = args[0].type;\n\t\tconst description = `\\`${event_name}\\` handler${location}`;\n\t\tconst suggestion = remove_parens ? 'remove the trailing `()`' : 'add a leading `() =>`';\n\n\t\tw.event_handler_invalid(description, suggestion);\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\t}\n}\n"],"names":["without_reactive_context","fn","previous_reaction","active_reaction","previous_effect","active_effect","set_active_reaction","set_active_effect","all_registered_events","root_event_handles","create_event","event_name","dom","handler","options","target_handler","event","handle_event_propagation","queue_micro_task","on","element","type","capture","passive","teardown","delegate","events","i","handler_element","owner_document","path","_a","current_target","path_idx","handled_at","at_idx","handler_idx","define_property","throw_error","other_errors","parent_element","delegated","is_array","data","error"],"mappings":"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","x_google_ignoreList":[0,1]}
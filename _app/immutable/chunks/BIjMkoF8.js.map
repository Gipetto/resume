{"version":3,"file":"BIjMkoF8.js","sources":["../../../../../../node_modules/svelte/src/internal/client/dom/blocks/html.js"],"sourcesContent":["/** @import { Effect, TemplateNode } from '#client' */\nimport { FILENAME, HYDRATION_ERROR } from '../../../../constants.js';\nimport { block, branch, destroy_effect } from '../../reactivity/effects.js';\nimport { hydrate_next, hydrate_node, hydrating, set_hydrate_node } from '../hydration.js';\nimport { create_fragment_from_html } from '../reconciler.js';\nimport { assign_nodes } from '../template.js';\nimport * as w from '../../warnings.js';\nimport { hash, sanitize_location } from '../../../../utils.js';\nimport { DEV } from 'esm-env';\nimport { dev_current_component_function } from '../../context.js';\nimport { get_first_child, get_next_sibling } from '../operations.js';\n\n/**\n * @param {Element} element\n * @param {string | null} server_hash\n * @param {string} value\n */\nfunction check_hash(element, server_hash, value) {\n\tif (!server_hash || server_hash === hash(String(value ?? ''))) return;\n\n\tlet location;\n\n\t// @ts-expect-error\n\tconst loc = element.__svelte_meta?.loc;\n\tif (loc) {\n\t\tlocation = `near ${loc.file}:${loc.line}:${loc.column}`;\n\t} else if (dev_current_component_function?.[FILENAME]) {\n\t\tlocation = `in ${dev_current_component_function[FILENAME]}`;\n\t}\n\n\tw.hydration_html_changed(sanitize_location(location));\n}\n\n/**\n * @param {Element | Text | Comment} node\n * @param {() => string} get_value\n * @param {boolean} svg\n * @param {boolean} mathml\n * @param {boolean} [skip_warning]\n * @returns {void}\n */\nexport function html(node, get_value, svg, mathml, skip_warning) {\n\tvar anchor = node;\n\n\tvar value = '';\n\n\t/** @type {Effect | undefined} */\n\tvar effect;\n\n\tblock(() => {\n\t\tif (value === (value = get_value() ?? '')) {\n\t\t\tif (hydrating) {\n\t\t\t\thydrate_next();\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\tif (effect !== undefined) {\n\t\t\tdestroy_effect(effect);\n\t\t\teffect = undefined;\n\t\t}\n\n\t\tif (value === '') return;\n\n\t\teffect = branch(() => {\n\t\t\tif (hydrating) {\n\t\t\t\t// We're deliberately not trying to repair mismatches between server and client,\n\t\t\t\t// as it's costly and error-prone (and it's an edge case to have a mismatch anyway)\n\t\t\t\tvar hash = /** @type {Comment} */ (hydrate_node).data;\n\t\t\t\tvar next = hydrate_next();\n\t\t\t\tvar last = next;\n\n\t\t\t\twhile (\n\t\t\t\t\tnext !== null &&\n\t\t\t\t\t(next.nodeType !== 8 || /** @type {Comment} */ (next).data !== '')\n\t\t\t\t) {\n\t\t\t\t\tlast = next;\n\t\t\t\t\tnext = /** @type {TemplateNode} */ (get_next_sibling(next));\n\t\t\t\t}\n\n\t\t\t\tif (next === null) {\n\t\t\t\t\tw.hydration_mismatch();\n\t\t\t\t\tthrow HYDRATION_ERROR;\n\t\t\t\t}\n\n\t\t\t\tif (DEV && !skip_warning) {\n\t\t\t\t\tcheck_hash(/** @type {Element} */ (next.parentNode), hash, value);\n\t\t\t\t}\n\n\t\t\t\tassign_nodes(hydrate_node, last);\n\t\t\t\tanchor = set_hydrate_node(next);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tvar html = value + '';\n\t\t\tif (svg) html = `<svg>${html}</svg>`;\n\t\t\telse if (mathml) html = `<math>${html}</math>`;\n\n\t\t\t// Don't use create_fragment_with_script_from_html here because that would mean script tags are executed.\n\t\t\t// @html is basically `.innerHTML = ...` and that doesn't execute scripts either due to security reasons.\n\t\t\t/** @type {DocumentFragment | Element} */\n\t\t\tvar node = create_fragment_from_html(html);\n\n\t\t\tif (svg || mathml) {\n\t\t\t\tnode = /** @type {Element} */ (get_first_child(node));\n\t\t\t}\n\n\t\t\tassign_nodes(\n\t\t\t\t/** @type {TemplateNode} */ (get_first_child(node)),\n\t\t\t\t/** @type {TemplateNode} */ (node.lastChild)\n\t\t\t);\n\n\t\t\tif (svg || mathml) {\n\t\t\t\twhile (get_first_child(node)) {\n\t\t\t\t\tanchor.before(/** @type {Node} */ (get_first_child(node)));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tanchor.before(node);\n\t\t\t}\n\t\t});\n\t});\n}\n"],"names":["html","node","get_value","svg","mathml","skip_warning","anchor","value","effect","block","hydrating","hydrate_next","destroy_effect","branch","hydrate_node","next","last","get_next_sibling","w.hydration_mismatch","HYDRATION_ERROR","assign_nodes","set_hydrate_node","create_fragment_from_html","get_first_child"],"mappings":"iJAyCO,SAASA,EAAKC,EAAMC,EAAWC,EAAKC,EAAQC,EAAc,CAChE,IAAIC,EAASL,EAETM,EAAQ,GAGRC,EAEJC,EAAM,IAAM,CACX,GAAIF,KAAWA,EAAQL,EAAW,GAAI,IAAK,CACtCQ,GACHC,EAAc,EAEf,MACH,CAEMH,IAAW,SACdI,EAAeJ,CAAM,EACrBA,EAAS,QAGND,IAAU,KAEdC,EAASK,EAAO,IAAM,CACrB,GAAIH,EAAW,CAGqBI,EAAc,KAIjD,QAHIC,EAAOJ,EAAc,EACrBK,EAAOD,EAGVA,IAAS,OACRA,EAAK,WAAa,GAA6BA,EAAM,OAAS,KAE/DC,EAAOD,EACPA,EAAoCE,EAAiBF,CAAI,EAG1D,GAAIA,IAAS,KACZG,MAAAA,EAAsB,EAChBC,EAOPC,EAAaN,EAAcE,CAAI,EAC/BV,EAASe,EAAiBN,CAAI,EAC9B,MACJ,CAEG,IAAIf,EAAOO,EAAQ,GACfJ,IAAKH,EAAO,QAAQA,CAAI,UAM5B,IAAIC,EAAOqB,EAA0BtB,CAAI,EAWzC,IATIG,GAAOC,KACVH,EAA+BsB,EAAgBtB,CAAI,GAGpDmB,EAC8BG,EAAgBtB,CAAI,EACpBA,EAAK,SAClC,EAEGE,GAAOC,EACV,KAAOmB,EAAgBtB,CAAI,GAC1BK,EAAO,OAA4BiB,EAAgBtB,CAAI,CAAG,OAG3DK,EAAO,OAAOL,CAAI,CAEtB,CAAG,EACH,CAAE,CACF","x_google_ignoreList":[0]}